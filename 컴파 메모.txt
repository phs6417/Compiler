0831

컴파일러 와 인터프리터 차이

컴파일러 ( C/C++ , JAVA )

: 번역을 마친다음 실행 -> 빠르다


인터프리터 ( Python , JavaScript )

: 한 문장씩 번역 실행 , 번역 실행 반복 -> 느리다

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

어셈블러

: 어셈블리어 -> 기계어 로 바꿔주는 프로그램

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

컴파일 과정

후단부 코드 최적화 (없을 시 비효율적이고 느리다)

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

오류처리

: 어느 곳이 틀렸는지 찾아주는 방법은 어렵다

--------------------------------------------------------------

0907

컴파2장 언어와문법
9/21

문맥의존문법
원소가 공집합인경우가 유일하게 1<=0 인 경우다

---------------------------------------------------------------


0912

컴파2장 언어와문법
19/21 2번째 G2

(* = 0번 이상 반복 , + = 1번 이상 반복)

C = c* d
B = b* cC = b* c c* d = b* c+ d
A = a* bB = a* b b* c* d = a* b+ c+ d
S = aA = a a* b+ c+ d = a+ b+ c+ d

20/21 3번째 G5

S -> a aS b | a b b  (A 가 없다)  a^2n abb b^n
A -> a S | b


연습문제2 4-(2) 기억해두기


---------------------------------------------------------------

0914

컴파3장 정규식과 오토마타

CFG (context free grammer)
BNF (베커스 나우어 format) -> 사람이름임 (CFG랑 같은말)


7/40

나열할때 '-' 는 쓸 일이 없다.


11/40
정규문법-1

X = aX + (bY + a) = a* (bY+a) = a* bY + a+
Y = aY + (bX + b) = a* (bX+b)

a* bY + a+ 에서 Y 에 a* (bX+b) 대입

X = (a + ba* b)X + (ba* b + a) = (a + ba*b)+


정규문법-2

Z = b* (cX + aY + c)

Y = bX + cY + ab* cX + ab* aY + ab* c + b
  = (c + ab* a)* (bX + ab* cX + ab* c + b)
  = ___X + ____ (꼴로 나타내기)


------------------------------------------------------------

0919

컴파3장 정규식과 오토마타

13/40

상태전이표(표)
: 다음 스테이트를 보기 쉽다. 경로(path)
C-d -> D(X) F(O)
상태전이표 옆에 Finite State = { } 다 라는 언급을 해줘야한다.

상태전이도 (그림)
: 직관성이 좋다

NFA -> DFA
: n개를 조합해서 2^n -1 개 까지 만들 수 있다.

DFA : 구현 쉽다

NFA : 구현 어렵다 (백트레킹 해야함)

----------------------------------------------------

0921

1. 정규표현식 (Regular Expression) 

: a* b    

2. 정규문법 (생성과정이 목적)

: S -> aS | b (규칙을 발견하기 위해 짧은 것부터 바꿔본다)


3. F.A (유한 오토마타 , 인식 목적)

: 상태전이도  ex)aaab 가 옳은지 틀린지 판별

	C언어 go to label 로 구현 가능



23/40

H = b* (aD + ε)
  = b* aD + b*

-----------------------------------------------------------

0926

dfa.c 에서 STATE , SYMBOL 그리고 마지막의 Final State (cur_state == ? ) 부분만

수정해주면 된다.


	쉬움
정규문법 -> 정규표현식
정규문법 -> 유한오토마타
유한오토마타 -> 정규문법
유한오토마타 -> 정규표현식 (유한->문법->표현) 

정규표현식 -> 유한오토마타 (34/40)


--------------------------------------------------------

0928

컴파3장 - 수정
29/42 잘봐두기

38/42
둘다 터미널인 경우는 ε이 필요없다
둘중 하나만 터미널인 경우도 마찬가지

(1+01)* 00 (0+1)*

NFA
	0	1
A	{B,C}	A		      1  0    0   0,1
B		A		ㅇ -> A  -> C -> D
C	D			     0|1
D	D	D		      B

NFA->DFA	
	0	1
1[A]	[B,C]	[A]
2[B,C]	[D]	[A]
3[D]	[D]	[D]


a^n b^n 를 정규언어라 가정

ω = a .... a b .... b
   = a...a ( a ..a b ..b ) b...b
   =   α 	β* 	     γ  로 표현 가능

1) β가 a* 인 경우
	α β* γ로 표현 불가능

2) β가 b* 인 경우
	α β* γ로 표현 불가능

3) β가 a와b로 이루어진 경우
	α β* γ로 표현 불가능 ( β* 로 a...a b...b 표현 불가능 )

---> 모든 경우가 불가능하니 가정이 잘못 ( a^n b^n 가 정규언어 라는 가정)

---> a^n b^n 은 정규언어가 아니다.


컴파4장

4/18
프로그래밍할 때의 순서 때문에 랜덤은 X

좌단유도 : 탑다운 파싱 , left parse 1 3 2 3 3
우단유도 : E->a
우단 역유도 : a->E , right parse 3 3 3 2 1


--------------------

1010

노트에 필기.

16년도 중간고사 기출

3.1 문장을 만들 수 없다
3.2 6가지만 만들 수 있다(유한) - 정규언어를 정규문법..?

우선형 문법 -> 좌선형 문법

5. A -> aA | B
   B -> bB | C
   C -> 엡실론

7. B = bc* (정규문법)이므로 대입
   A = abc* c + a

8. a^m 과 b^n c^n 의 결합

   S -> AB

   A -> aA | a

   B -> bBc | bc


9번까지 시험범위

--------------------------------------- 중간고사 이후

1024

컴파4장 보충 - PDA 작동원리

6/13
트리로 만들었을 때 이진트리 형식으로 나온다

A -> aα
A -> aβ
인 경우 NFA 다

A -> aX
X -> α|β 로 표현

7/13
논터미널은 네모칸
터미널은 둥근칸

8/13
Z -> 스택의 최정상 상태


13/13
(3) 이랑 (4) 같은거임 - 수정 필요

--------------------------------------- 

1026

컴파5장 탑다운 구문분석

LL 파싱
-왼쪽에서 오른쪽으로 읽음 & 좌단 유도

3/27
예1 ) a c e b $ 의 경우
① -> ⑤ -> ⑦ 적용되면 aA -> a cBb -> a c e b 가 된다

예2 ) S -> AbB | BbB 에서 

A (교집합이 없는 , 서로 다른)3가지 ,
B 3가지 경우가 가능하고 Deterministic 하다


5/27
하나를 봐서는 Deterministic 하진 않지만 2개를 보면 Deterministic 하다

7/27
FIRST(AbB) 와 FIRST(A) 는 다르다
A -> 엡실론 | ㅇㅇㅇ
엡실론이 포함될 경우 다음 터미널을 본다


10/27

FIRST(S) = {a , b , c, 엡실론}
FIRST(A) = {a , b , d}
FIRST(B) = {b, 엡실론}

F(A) = F(aAb) U F(BBd) 

     = {a} U  	F(B) 링섬 F(B) 링섬 F(d)
	      {b,엡실론}

     = {a} U 	{b,엡실론} 링섬 {b,엡실론} 링섬 {d}
   
     = {a , b , d}

11/27

A -> BbA | c
B -> b | 엡실론

b가 왔을때 B가 b인지 엡실론인지 결정X

13/27

FOLLOW(S) = $
FOLLOW(A) = {b}
FOLLOW(B) = {b,c,d}

FOLLOW(B) = FIRST(b) U FIRST(cb) U FIRST(Bd) U FIRST(d)

	  = {b} U {c} U FIRST(Bd) U {d}

	  = 		{b,d}

	  = {b,c,d}

FIRST(Bd) = FIRST(B) 링섬 FIRST(d)

	  = {b.d}

---------------------------------------------------

1031

A -> αB

=> ....Aoo....
=> ....αBoo.....

FOLLOW(B) = FOLLOW(A) = o 

컴파5장
12/27
3) A -> 엡실론은 오타


A -> Bc | De
B -> aB | bC
D -> c | d

L.A(D->c) = {c}
L.A(D->d) = {d}

L.A(A->Bc) = {a,b}
L.A(A->De) = {c.d}

22/27
FIRST(A) = FIRST(Ba) U {c}

	 = {b, a , c}

FIRST(B) = {b, 엡실론}

FOLLOW(A) = FIRST(B) U {$}

	  = {b, $ , 엡실론}

 // FOLLOW 에선 엡실론이 있으면 안된다

	  = {b, $ } U FOLLOW(B)

 // 	  = {a, b, $}

FOLLOW(B) = {a} U FOLLOW(B)

	  = {a}

LOOKAHEAD(A->Ba) = {b,a}

LOOKAHEAD(A->c) = {c}

LOOKAHEAD(B->bAB) = {b}

LOOKAHEAD(B->엡실론) = FOLLOW(B) = {a}

교집합이 없으므로 파싱 가능


-----------------------------------------

1102

E -> E+E | E*E | (E) | a

FIRST(E) = { (, a }
FOLLOW(E) = { $, +, *, ) }

LL(1) 만족하지 않는다 / 모호하다


E -> E+T | T
T -> T*F | F
F -> (E) | a

좌순환 문제가 생긴다 -> 우순환으로 바꿔준다

E -> E  +T |  T
     A 알파| 베타

이므로

E -> TE'		0
E'-> +TE' | 엡실론	1	2
T -> FT'		3
T'-> *FT' | 엡실론	4	5
F -> (E) | a		6	7


FIRST(E) = { (,a }
FIRST(T) = { (,a }
FIRST(F) = { (,a }	

FIRST(E')= { +, 엡실론 }
FIRST(T')= { *, 엡실론 }

FOLLOW(E) = { $, ) }
FOLLOW(E')= { $, ) }
FOLLOW(T) = { +, $, ) }
FOLLOW(T')= { +, $, ) }
FOLLOW(F) = { *, +, $, ) }

파싱표

	a	+	*	(	)	$

E	0			0		

E'		1			2	2

T	3			3		

T'		5	4		5	5

F	7			6		


a + a * a $ 일 경우


-----------------------------------------------------

1107

컴파5장

25/27
Predictive 파서를 잘 쓰기 위해선 파싱표가 필요

파싱표를 짜기 위해선  FIRST, FOLLOW, LOOKAHEAD 를 구하는 프로그램 필요

Left factoring 하는 프로그램도 필요


숙제 코멘트
먼저 좌순환을 해결
, -> + 처럼 생각

컴파6장

10/35
CFG 를 통해서 LR파싱표를 만든다 (무척 어렵)
    
12/35
'(dot)의 의미
	D
	C
스택이	B 일 경우 A 로 리듀스 된다  ( A -> B C D ' )


	C	
스택이	B 인 경우 D가 들어오면 A가 리듀스 된다 ( A -> B C ' D )


-----------------------------------------------------

1114

컴파6장 23/35

[S' -> ㆍS]	S->	[S' -> Sㆍ]
	     

[S -> ㆍbAb]	b->	[S -> bㆍAb]	A->
			[A -> ㆍaAb]	a->	[A -> aㆍAb]
						[A -> ㆍaAb]
						[A -> ㆍbBa]

			[A -> ㆍbBa]	b->	[A -> bㆍBa]
						[B -> ㆍb]
						[B -> ㆍ]

[S -> ㆍaB]	a->	[S -> aㆍB]
			[B -> ㆍb]
			[B -> ㆍ]


[S -> ㆍ ]		.....

-----------------------------------------------

1121

Lex & Yacc1

Lex 규칙부가 핵심
.  : 아무 문자 하나

08/17
yylex() 는 stdin 을 받는다 (표준 입력)

printf를 사용할시 stdio.h 가 필요하다
#include <~~~> 를 가장 위에 쓴다

길이가 가장 긴 것을 우선으로 한다
(int 의 경우 in + t 가 아니라 int 로 먼저 매칭)

09/17
[ a-zA-Z ] 아스키코드의 순서대로 기술한다

14/17
yyin = stdin;
yyout = stdout;
EOF = ^D  (컨트롤 D)

[ ^ ~~~ ] 대괄호 안 ^ 은 ~~~를 제외한 아무거나 집합
  ex)  [^ \t\n] 블랭크와 줄바꿈을 제외한 집합

15/17
yywrap() 을 통하여 여러개의 파일을 한번에 처리 할 수 있다
파일의 끝인 EOF 을 만날 시 yywrap() 파일의 끝인지 아닌지 판별



--------------------------------------------------------------

1123

컴파6장 Bottomup

32/35


-----------------------------

1130

컴파7장 컴파일러 구현

어휘분석기 만드는3가지
1.그냥 만들기
2.오타마타 사용
3.lex를 사용하여 어휘분석기

2/21
토큰넘버를 부여하여 맵핑

		E
				E
	E		E		E

값	100	+	200	*	3
	
토큰no.	1	51	1	52	1

<1,100>
<51, 공집합>
<1,100>
<52, 공집합>
<1, 3>

4/21
한 라인에 하나의 규칙
 |로 다른 규칙을 다음 라인에 서술

-------------------------------

yacc

abc.y 랑 calc2.y 

$$  -> 변수 (LHS 의 값)

expr '+' expr	{ $$ = $1 + $3; }

우선순위 해결방법 ( +,* )
1. E -> T 로 바꾼다
2. 좌결합처리
%right	'='
%left	'+' '-'	/* left assoc. -- same priority */
%left	'*' '/'	/* left assoc. -- same priority */
%nonassoc	UNARYMINUS

아래에 있을수록 우선순위가 높다

%token	<index>	VAR   -> yacc가 알아서 토큰넘버를 부여한다
%token	<val>	NUMBER

실습13,14 미니 파스칼 , 미니 c 해보기


